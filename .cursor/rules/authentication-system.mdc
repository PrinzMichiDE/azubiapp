# Authentifizierungssystem und NextAuth.js-Integration

## Authentifizierungs-Überblick
- **Framework**: Auth.js (NextAuth.js) für flexible Authentifizierung
- **Methoden**: Basis-Auth (E-Mail/Passwort) und OAuth (Microsoft Entra ID)
- **Sicherheit**: JWT, bcrypt, CSRF-Schutz, DSGVO-konform
- **Konfiguration**: Steuerung über .env-Variablen
- **Rollen**: AZUBI, AUSBILDER, ADMIN mit RBAC

## NextAuth.js Konfiguration
```typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import AzureADProvider from 'next-auth/providers/azure-ad';
import bcrypt from 'bcryptjs';
import prisma from '@/lib/prisma';

export const authOptions = {
  providers: [
    // Basis-Authentifizierung (E-Mail/Passwort)
    ...(process.env.AUTH_BASIC_ENABLED === 'true' ? [
      CredentialsProvider({
        name: 'Credentials',
        credentials: {
          email: { label: 'E-Mail', type: 'email' },
          password: { label: 'Passwort', type: 'password' },
        },
        async authorize(credentials) {
          if (!credentials?.email || !credentials?.password) {
            throw new Error('E-Mail und Passwort erforderlich');
          }

          // Benutzer in Datenbank suchen
          const user = await prisma.user.findUnique({ 
            where: { email: credentials.email },
            select: {
              id: true,
              email: true,
              password: true,
              role: true,
              firstName: true,
              lastName: true,
              isActive: true,
              emailVerified: true
            }
          });

          if (!user || !user.password || !user.isActive) {
            throw new Error('Ungültige Anmeldedaten oder Konto deaktiviert');
          }

          // Passwort validieren
          const isValid = await bcrypt.compare(credentials.password, user.password);
          if (!isValid) {
            throw new Error('Ungültige Anmeldedaten');
          }

          // E-Mail-Verifizierung prüfen (falls aktiviert)
          if (process.env.EMAIL_VERIFICATION_REQUIRED === 'true' && !user.emailVerified) {
            throw new Error('E-Mail-Adresse muss verifiziert werden');
          }

          return {
            id: user.id,
            email: user.email,
            role: user.role,
            firstName: user.firstName,
            lastName: user.lastName
          };
        },
      }),
    ] : []),

    // Microsoft Entra ID OAuth
    ...(process.env.AUTH_ENTRA_ENABLED === 'true' ? [
      AzureADProvider({
        clientId: process.env.ENTRA_CLIENT_ID!,
        clientSecret: process.env.ENTRA_CLIENT_SECRET!,
        tenantId: process.env.ENTRA_TENANT_ID!,
        authorization: {
          params: {
            scope: 'openid profile email User.Read'
          }
        }
      }),
    ] : []),
  ],

  callbacks: {
    // JWT-Callback für Token-Erweiterung
    async jwt({ token, user, account }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
        token.firstName = user.firstName;
        token.lastName = user.lastName;
      }

      // Entra ID OAuth - Benutzer in DB synchronisieren
      if (account?.provider === 'azure-ad' && account.access_token) {
        try {
          const userInfo = await fetchUserInfoFromEntra(account.access_token);
          const dbUser = await syncUserWithEntra(userInfo);
          
          token.id = dbUser.id;
          token.role = dbUser.role;
          token.firstName = dbUser.firstName;
          token.lastName = dbUser.lastName;
        } catch (error) {
          console.error('Entra ID sync error:', error);
        }
      }

      return token;
    },

    // Session-Callback für Client-seitige Daten
    async session({ session, token }) {
      if (token) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
        session.user.firstName = token.firstName as string;
        session.user.lastName = token.lastName as string;
      }
      return session;
    },

    // Sign-In-Callback für zusätzliche Validierung
    async signIn({ user, account, profile }) {
      // Entra ID OAuth - Benutzer aktivieren/erstellen
      if (account?.provider === 'azure-ad') {
        try {
          await handleEntraSignIn(user, profile);
          return true;
        } catch (error) {
          console.error('Entra sign-in error:', error);
          return false;
        }
      }

      return true;
    },
  },

  session: {
    strategy: 'jwt',
    maxAge: 24 * 60 * 60, // 24 Stunden
    updateAge: 60 * 60, // 1 Stunde
  },

  pages: {
    signIn: '/login',
    signUp: '/register',
    error: '/auth/error',
    verifyRequest: '/auth/verify-request',
  },

  events: {
    async signIn({ user, account, profile, isNewUser }) {
      // Audit-Log für Anmeldungen
      await logSignInEvent({
        userId: user.id,
        provider: account?.provider || 'credentials',
        timestamp: new Date(),
        isNewUser
      });
    },

    async signOut({ session, token }) {
      // Audit-Log für Abmeldungen
      if (token?.id) {
        await logSignOutEvent({
          userId: token.id,
          timestamp: new Date()
        });
      }
    },
  },

  // Sicherheitskonfiguration
  secret: process.env.NEXTAUTH_SECRET,
  debug: process.env.NODE_ENV === 'development',
};

export const { handlers, signIn, signOut, auth } = NextAuth(authOptions);
```

## Entra ID Integration
```typescript
// lib/entra-integration.ts
interface EntraUserInfo {
  id: string;
  displayName: string;
  givenName: string;
  surname: string;
  userPrincipalName: string;
  mail: string;
  jobTitle?: string;
  department?: string;
  companyName?: string;
}

// Benutzer-Informationen von Entra ID abrufen
export async function fetchUserInfoFromEntra(accessToken: string): Promise<EntraUserInfo> {
  const response = await fetch('https://graph.microsoft.com/v1.0/me', {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error('Fehler beim Abrufen der Entra ID Benutzerdaten');
  }

  const userData = await response.json();
  
  return {
    id: userData.id,
    displayName: userData.displayName,
    givenName: userData.givenName,
    surname: userData.surname,
    userPrincipalName: userData.userPrincipalName,
    mail: userData.mail || userData.userPrincipalName,
    jobTitle: userData.jobTitle,
    department: userData.department,
    companyName: userData.companyName
  };
}

// Benutzer mit Entra ID synchronisieren
export async function syncUserWithEntra(userInfo: EntraUserInfo) {
  const existingUser = await prisma.user.findUnique({
    where: { email: userInfo.mail }
  });

  if (existingUser) {
    // Bestehenden Benutzer aktualisieren
    return await prisma.user.update({
      where: { id: existingUser.id },
      data: {
        firstName: userInfo.givenName,
        lastName: userInfo.surname,
        entraId: userInfo.id,
        lastEntraSync: new Date(),
        jobTitle: userInfo.jobTitle,
        department: userInfo.department,
        companyName: userInfo.companyName
      }
    });
  } else {
    // Neuen Benutzer erstellen
    const role = await determineRoleFromEntra(userInfo);
    
    return await prisma.user.create({
      data: {
        email: userInfo.mail,
        firstName: userInfo.givenName,
        lastName: userInfo.surname,
        entraId: userInfo.id,
        role,
        isActive: true,
        emailVerified: true, // Entra ID ist bereits verifiziert
        lastEntraSync: new Date(),
        jobTitle: userInfo.jobTitle,
        department: userInfo.department,
        companyName: userInfo.companyName
      }
    });
  }
}

// Rolle basierend auf Entra ID Gruppen bestimmen
async function determineRoleFromEntra(userInfo: EntraUserInfo): Promise<string> {
  // Hier könnte die Logik implementiert werden, um basierend auf
  // Azure AD Gruppen die Rolle zu bestimmen
  // Für jetzt: Standardrolle AZUBI
  return 'AZUBI';
}

// Entra ID Anmeldung verarbeiten
export async function handleEntraSignIn(user: any, profile: any) {
  // Zusätzliche Logik für Entra ID Anmeldungen
  // z.B. Gruppen-Membership prüfen, Rollen aktualisieren
  
  await prisma.user.update({
    where: { id: user.id },
    data: {
      lastLogin: new Date(),
      loginCount: { increment: 1 }
    }
  });
}
```

## Registrierungs-API
```typescript
// app/api/register/route.ts
import { NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { sendVerificationEmail } from '@/lib/email';

const registerSchema = z.object({
  email: z.string().email('Ungültige E-Mail-Adresse'),
  password: z.string()
    .min(8, 'Passwort muss mindestens 8 Zeichen lang sein')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Passwort muss Groß- und Kleinbuchstaben sowie Zahlen enthalten'),
  passwordConfirm: z.string(),
  firstName: z.string().min(2, 'Vorname muss mindestens 2 Zeichen lang sein'),
  lastName: z.string().min(2, 'Nachname muss mindestens 2 Zeichen lang sein'),
  companyCode: z.string().optional(),
  acceptTerms: z.boolean().refine(val => val === true, 'Sie müssen den AGB zustimmen'),
  acceptPrivacy: z.boolean().refine(val => val === true, 'Sie müssen der Datenschutzerklärung zustimmen')
}).refine((data) => data.password === data.passwordConfirm, {
  message: "Passwörter stimmen nicht überein",
  path: ["passwordConfirm"]
});

export async function POST(request: Request) {
  // Prüfen ob Basis-Auth aktiviert ist
  if (process.env.AUTH_BASIC_ENABLED !== 'true') {
    return NextResponse.json(
      { error: 'Registrierung ist derzeit deaktiviert' },
      { status: 403 }
    );
  }

  try {
    const body = await request.json();
    const validatedData = registerSchema.parse(body);

    // E-Mail bereits vergeben?
    const existingUser = await prisma.user.findUnique({
      where: { email: validatedData.email }
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'Diese E-Mail-Adresse ist bereits registriert' },
        { status: 400 }
      );
    }

    // Passwort hashen
    const hashedPassword = await bcrypt.hash(validatedData.password, 12);

    // Rolle bestimmen
    let role = 'AZUBI';
    if (validatedData.companyCode) {
      const company = await prisma.company.findUnique({
        where: { code: validatedData.companyCode }
      });
      if (company) {
        role = company.defaultRole || 'AZUBI';
      }
    }

    // Benutzer erstellen
    const user = await prisma.user.create({
      data: {
        email: validatedData.email,
        password: hashedPassword,
        firstName: validatedData.firstName,
        lastName: validatedData.lastName,
        role,
        isActive: true,
        emailVerified: process.env.EMAIL_VERIFICATION_REQUIRED === 'true' ? false : true,
        companyCode: validatedData.companyCode,
        acceptTerms: validatedData.acceptTerms,
        acceptPrivacy: validatedData.acceptPrivacy,
        acceptTermsAt: new Date(),
        acceptPrivacyAt: new Date()
      }
    });

    // E-Mail-Verifizierung senden (falls aktiviert)
    if (process.env.EMAIL_VERIFICATION_REQUIRED === 'true') {
      const verificationToken = await createVerificationToken(user.id);
      await sendVerificationEmail(user.email, verificationToken);
    }

    // Audit-Log
    await prisma.auditLog.create({
      data: {
        action: 'USER_REGISTERED',
        userId: user.id,
        details: {
          method: 'credentials',
          companyCode: validatedData.companyCode
        }
      }
    });

    return NextResponse.json({
      success: true,
      message: process.env.EMAIL_VERIFICATION_REQUIRED === 'true' 
        ? 'Registrierung erfolgreich. Bitte bestätigen Sie Ihre E-Mail-Adresse.'
        : 'Registrierung erfolgreich. Sie können sich jetzt anmelden.',
      userId: user.id,
      requiresVerification: process.env.EMAIL_VERIFICATION_REQUIRED === 'true'
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validierungsfehler',
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        },
        { status: 400 }
      );
    }

    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'Ein Fehler ist bei der Registrierung aufgetreten' },
      { status: 500 }
    );
  }
}

// E-Mail-Verifizierungstoken erstellen
async function createVerificationToken(userId: string): Promise<string> {
  const token = crypto.randomUUID();
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 Stunden

  await prisma.verificationToken.create({
    data: {
      identifier: userId,
      token,
      expires: expiresAt
    }
  });

  return token;
}
```

## Middleware für geschützte Routen
```typescript
// middleware.ts
import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token;
    const { pathname } = req.nextUrl;

    // Admin-Bereich nur für Admins
    if (pathname.startsWith('/admin') && token?.role !== 'ADMIN') {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }

    // Ausbilder-Bereich nur für Ausbilder und Admins
    if (pathname.startsWith('/trainer') && 
        !['AUSBILDER', 'ADMIN'].includes(token?.role || '')) {
      return NextResponse.redirect(new URL('/unauthorized', req.url));
    }

    // HR-Integration nur für Admins
    if (pathname.startsWith('/api/hr') && token?.role !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Keine Berechtigung' },
        { status: 403 }
      );
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token
    },
    pages: {
      signIn: '/login',
    }
  }
);

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/admin/:path*',
    '/trainer/:path*',
    '/profile/:path*',
    '/api/hr/:path*'
  ]
};
```

## E-Mail-Verifizierung
```typescript
// app/api/auth/verify/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const token = searchParams.get('token');

  if (!token) {
    return NextResponse.json(
      { error: 'Verifizierungstoken fehlt' },
      { status: 400 }
    );
  }

  try {
    // Token in Datenbank suchen
    const verificationToken = await prisma.verificationToken.findUnique({
      where: { token }
    });

    if (!verificationToken) {
      return NextResponse.json(
        { error: 'Ungültiger Verifizierungstoken' },
        { status: 400 }
      );
    }

    if (verificationToken.expires < new Date()) {
      // Token gelöscht
      await prisma.verificationToken.delete({
        where: { id: verificationToken.id }
      });
      
      return NextResponse.json(
        { error: 'Verifizierungstoken ist abgelaufen' },
        { status: 400 }
      );
    }

    // Benutzer verifizieren
    await prisma.user.update({
      where: { id: verificationToken.identifier },
      data: { emailVerified: true }
    });

    // Token löschen
    await prisma.verificationToken.delete({
      where: { id: verificationToken.id }
    });

    // Audit-Log
    await prisma.auditLog.create({
      data: {
        action: 'EMAIL_VERIFIED',
        userId: verificationToken.identifier
      }
    });

    return NextResponse.json({
      success: true,
      message: 'E-Mail-Adresse erfolgreich verifiziert'
    });

  } catch (error) {
    console.error('Email verification error:', error);
    return NextResponse.json(
      { error: 'Fehler bei der E-Mail-Verifizierung' },
      { status: 500 }
    );
  }
}
```

## Passwort-Reset
```typescript
// app/api/auth/reset-password/route.ts
import { NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { sendPasswordResetEmail } from '@/lib/email';

const resetPasswordSchema = z.object({
  email: z.string().email('Ungültige E-Mail-Adresse')
});

const updatePasswordSchema = z.object({
  token: z.string(),
  password: z.string()
    .min(8, 'Passwort muss mindestens 8 Zeichen lang sein')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Passwort muss Groß- und Kleinbuchstaben sowie Zahlen enthalten')
});

// Passwort-Reset anfordern
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email } = resetPasswordSchema.parse(body);

    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      // Aus Sicherheitsgründen keine Information über existierende E-Mails
      return NextResponse.json({
        success: true,
        message: 'Falls diese E-Mail-Adresse registriert ist, erhalten Sie eine E-Mail mit Anweisungen.'
      });
    }

    // Reset-Token erstellen
    const resetToken = crypto.randomUUID();
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 Stunde

    await prisma.passwordResetToken.create({
      data: {
        identifier: user.id,
        token: resetToken,
        expires: expiresAt
      }
    });

    // E-Mail senden
    await sendPasswordResetEmail(user.email, resetToken);

    return NextResponse.json({
      success: true,
      message: 'Falls diese E-Mail-Adresse registriert ist, erhalten Sie eine E-Mail mit Anweisungen.'
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Ungültige E-Mail-Adresse' },
        { status: 400 }
      );
    }

    console.error('Password reset request error:', error);
    return NextResponse.json(
      { error: 'Fehler bei der Passwort-Reset-Anfrage' },
      { status: 500 }
    );
  }
}

// Passwort mit Token aktualisieren
export async function PUT(request: Request) {
  try {
    const body = await request.json();
    const { token, password } = updatePasswordSchema.parse(body);

    // Token validieren
    const resetToken = await prisma.passwordResetToken.findUnique({
      where: { token }
    });

    if (!resetToken) {
      return NextResponse.json(
        { error: 'Ungültiger Reset-Token' },
        { status: 400 }
      );
    }

    if (resetToken.expires < new Date()) {
      await prisma.passwordResetToken.delete({
        where: { id: resetToken.id }
      });
      
      return NextResponse.json(
        { error: 'Reset-Token ist abgelaufen' },
        { status: 400 }
      );
    }

    // Passwort aktualisieren
    const hashedPassword = await bcrypt.hash(password, 12);
    
    await prisma.user.update({
      where: { id: resetToken.identifier },
      data: { password: hashedPassword }
    });

    // Token löschen
    await prisma.passwordResetToken.delete({
      where: { id: resetToken.id }
    });

    // Audit-Log
    await prisma.auditLog.create({
      data: {
        action: 'PASSWORD_RESET',
        userId: resetToken.identifier
      }
    });

    return NextResponse.json({
      success: true,
      message: 'Passwort erfolgreich aktualisiert'
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Ungültige Daten' },
        { status: 400 }
      );
    }

    console.error('Password update error:', error);
    return NextResponse.json(
      { error: 'Fehler beim Aktualisieren des Passworts' },
      { status: 500 }
    );
  }
}
```
description:
globs:
alwaysApply: true
---
