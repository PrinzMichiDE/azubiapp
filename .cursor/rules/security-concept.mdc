# Umfassendes Sicherheitskonzept

## Sicherheitsübersicht
- **Datenschutz**: DSGVO-Konformität und Datenminimierung
- **API-Sicherheit**: Rate Limiting, Input-Validierung, CORS
- **Authentifizierung**: OAuth 2.0, Session-Management, Token-Refresh
- **Verschlüsselung**: TLS, DB-Verschlüsselung, Passwort-Hashing
- **Audit & Monitoring**: Logging, Error-Tracking, Sicherheitsmetriken
- **Konfiguration**: Umgebungsvariablen für alle Sicherheits-Features

## Sicherheits-Middleware
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth/jwt';
import { rateLimiter } from '@/lib/security/rate-limiter';
import { auditLogger } from '@/lib/security/audit-logger';
import { corsMiddleware } from '@/lib/security/cors';
import { securityHeaders } from '@/lib/security/security-headers';

export async function middleware(request: NextRequest) {
  const startTime = Date.now();
  const requestId = generateRequestId();

  try {
    // 1. CORS-Prüfung
    const corsResponse = await corsMiddleware(request);
    if (corsResponse) return corsResponse;

    // 2. Rate Limiting
    const rateLimitResponse = await rateLimiter.check(request);
    if (rateLimitResponse) return rateLimitResponse;

    // 3. Sicherheits-Header
    const response = NextResponse.next();
    securityHeaders(response);

    // 4. Authentifizierung für geschützte Routen
    if (isProtectedRoute(request.nextUrl.pathname)) {
      const authResult = await verifyToken(request);
      if (!authResult.success) {
        auditLogger.log('auth_failure', {
          requestId,
          path: request.nextUrl.pathname,
          ip: request.ip,
          userAgent: request.headers.get('user-agent'),
          reason: authResult.reason,
        });

        return NextResponse.json(
          { error: 'Unauthorized', message: 'Zugriff verweigert' },
          { status: 401 }
        );
      }

      // Benutzer-ID für Audit-Logging
      request.headers.set('x-user-id', authResult.userId);
    }

    // 5. Request-Validierung
    if (request.method !== 'GET' && request.method !== 'HEAD') {
      const validationResult = await validateRequest(request);
      if (!validationResult.valid) {
        auditLogger.log('request_validation_failure', {
          requestId,
          path: request.nextUrl.pathname,
          method: request.method,
          ip: request.ip,
          errors: validationResult.errors,
        });

        return NextResponse.json(
          { error: 'Bad Request', message: 'Ungültige Anfrage', details: validationResult.errors },
          { status: 400 }
        );
      }
    }

    // 6. Audit-Logging für Admin-Aktionen
    if (isAdminRoute(request.nextUrl.pathname)) {
      auditLogger.log('admin_action', {
        requestId,
        path: request.nextUrl.pathname,
        method: request.method,
        userId: request.headers.get('x-user-id'),
        ip: request.ip,
        timestamp: new Date().toISOString(),
      });
    }

    // 7. Response-Processing
    const finalResponse = await processResponse(request, response);
    
    // 8. Performance-Monitoring
    const duration = Date.now() - startTime;
    if (duration > 1000) { // Langsame Requests loggen
      auditLogger.log('slow_request', {
        requestId,
        path: request.nextUrl.pathname,
        duration,
        ip: request.ip,
      });
    }

    return finalResponse;

  } catch (error) {
    // 9. Error-Handling und Logging
    auditLogger.log('middleware_error', {
      requestId,
      path: request.nextUrl.pathname,
      error: error.message,
      stack: error.stack,
      ip: request.ip,
    });

    return NextResponse.json(
      { error: 'Internal Server Error', message: 'Ein interner Fehler ist aufgetreten' },
      { status: 500 }
    );
  }
}

// Geschützte Routen definieren
function isProtectedRoute(pathname: string): boolean {
  const protectedPatterns = [
    /^\/api\/(?!public)/, // Alle API-Routen außer /api/public
    /^\/dashboard/,
    /^\/admin/,
    /^\/profile/,
    /^\/learn/,
  ];
  
  return protectedPatterns.some(pattern => pattern.test(pathname));
}

// Admin-Routen definieren
function isAdminRoute(pathname: string): boolean {
  return pathname.startsWith('/admin') || pathname.startsWith('/api/admin');
}

// Request-ID generieren
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Request-Validierung
async function validateRequest(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type');
    
    if (contentType?.includes('application/json')) {
      const body = await request.json();
      
      // Basis-Validierung für alle Requests
      if (body && typeof body === 'object') {
        // SQL-Injection-Schutz
        const sqlKeywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER'];
        const bodyString = JSON.stringify(body).toUpperCase();
        
        if (sqlKeywords.some(keyword => bodyString.includes(keyword))) {
          return { valid: false, errors: ['Potentiell gefährliche Eingabe erkannt'] };
        }
        
        // XSS-Schutz
        if (bodyString.includes('<SCRIPT>') || bodyString.includes('JAVASCRIPT:')) {
          return { valid: false, errors: ['Potentiell gefährliche Eingabe erkannt'] };
        }
      }
    }
    
    return { valid: true, errors: [] };
  } catch (error) {
    return { valid: false, errors: ['Request-Validierung fehlgeschlagen'] };
  }
}

// Response-Processing
async function processResponse(request: NextRequest, response: NextResponse) {
  // Zusätzliche Sicherheits-Header
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  
  return response;
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml).*)',
  ],
};
```

## Rate Limiting
```typescript
// lib/security/rate-limiter.ts
import { Redis } from '@upstash/redis';
import { NextRequest, NextResponse } from 'next/server';

interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  message: string;
  statusCode: number;
}

class RateLimiter {
  private redis: Redis;
  private configs: Map<string, RateLimitConfig>;

  constructor() {
    this.redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    });

    this.configs = new Map([
      ['default', { windowMs: 15 * 60 * 1000, maxRequests: 100, message: 'Zu viele Anfragen', statusCode: 429 }],
      ['auth', { windowMs: 15 * 60 * 1000, maxRequests: 5, message: 'Zu viele Anmeldeversuche', statusCode: 429 }],
      ['api', { windowMs: 60 * 1000, maxRequests: 60, message: 'API-Rate-Limit überschritten', statusCode: 429 }],
      ['upload', { windowMs: 60 * 1000, maxRequests: 10, message: 'Zu viele Uploads', statusCode: 429 }],
    ]);
  }

  async check(request: NextRequest): Promise<NextResponse | null> {
    const clientId = this.getClientId(request);
    const routeType = this.getRouteType(request.nextUrl.pathname);
    const config = this.configs.get(routeType) || this.configs.get('default')!;

    const key = `rate_limit:${routeType}:${clientId}`;
    const current = await this.redis.get(key) as number || 0;

    if (current >= config.maxRequests) {
      // Rate Limit überschritten
      const ttl = await this.redis.ttl(key);
      
      return NextResponse.json(
        {
          error: 'Rate Limit Exceeded',
          message: config.message,
          retryAfter: ttl,
          limit: config.maxRequests,
          window: config.windowMs,
        },
        {
          status: config.statusCode,
          headers: {
            'Retry-After': ttl.toString(),
            'X-RateLimit-Limit': config.maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': (Date.now() + ttl * 1000).toString(),
          },
        }
      );
    }

    // Rate Limit erhöhen
    await this.redis.incr(key);
    if (current === 0) {
      await this.redis.expire(key, Math.ceil(config.windowMs / 1000));
    }

    return null;
  }

  private getClientId(request: NextRequest): string {
    // IP-Adresse oder API-Key als Client-ID verwenden
    const apiKey = request.headers.get('x-api-key');
    if (apiKey) return `api:${apiKey}`;
    
    const ip = request.ip || request.headers.get('x-forwarded-for') || 'unknown';
    return `ip:${ip}`;
  }

  private getRouteType(pathname: string): string {
    if (pathname.startsWith('/api/auth')) return 'auth';
    if (pathname.startsWith('/api/upload')) return 'upload';
    if (pathname.startsWith('/api/')) return 'api';
    return 'default';
  }

  // Rate Limit für spezifische Benutzer
  async checkUserLimit(userId: string, action: string, maxRequests: number, windowMs: number): Promise<boolean> {
    const key = `user_rate_limit:${action}:${userId}`;
    const current = await this.redis.get(key) as number || 0;

    if (current >= maxRequests) {
      return false;
    }

    await this.redis.incr(key);
    if (current === 0) {
      await this.redis.expire(key, Math.ceil(windowMs / 1000));
    }

    return true;
  }
}

export const rateLimiter = new RateLimiter();
```

## CORS-Middleware
```typescript
// lib/security/cors.ts
import { NextRequest, NextResponse } from 'next/server';

interface CORSOptions {
  origin: string | string[] | boolean;
  methods: string[];
  allowedHeaders: string[];
  credentials: boolean;
  maxAge: number;
}

const corsOptions: CORSOptions = {
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://azubi-lxp.com', 'https://www.azubi-lxp.com']
    : ['http://localhost:3000', 'http://127.0.0.1:3000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'X-API-Key',
    'X-User-ID',
    'X-Request-ID',
  ],
  credentials: true,
  maxAge: 86400, // 24 Stunden
};

export async function corsMiddleware(request: NextRequest): Promise<NextResponse | null> {
  const origin = request.headers.get('origin');
  const method = request.method;

  // Preflight-Request behandeln
  if (method === 'OPTIONS') {
    const response = new NextResponse(null, { status: 200 });
    setCORSHeaders(response, origin);
    return response;
  }

  // Origin-Validierung
  if (origin && !isValidOrigin(origin)) {
    return NextResponse.json(
      { error: 'CORS Error', message: 'Ungültiger Origin' },
      { status: 403 }
    );
  }

  return null;
}

function setCORSHeaders(response: NextResponse, origin: string | null): void {
  if (origin && isValidOrigin(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
  }
  
  response.headers.set('Access-Control-Allow-Methods', corsOptions.methods.join(', '));
  response.headers.set('Access-Control-Allow-Headers', corsOptions.allowedHeaders.join(', '));
  response.headers.set('Access-Control-Allow-Credentials', corsOptions.credentials.toString());
  response.headers.set('Access-Control-Max-Age', corsOptions.maxAge.toString());
}

function isValidOrigin(origin: string): boolean {
  if (corsOptions.origin === true) return true;
  if (Array.isArray(corsOptions.origin)) {
    return corsOptions.origin.includes(origin);
  }
  if (typeof corsOptions.origin === 'string') {
    return corsOptions.origin === origin;
  }
  return false;
}
```

## Sicherheits-Header
```typescript
// lib/security/security-headers.ts
import { NextResponse } from 'next/server';

export function securityHeaders(response: NextResponse): void {
  // Content Security Policy
  const csp = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https: blob:",
    "media-src 'self' https:",
    "connect-src 'self' https: wss:",
    "frame-src 'self' https://js.stripe.com",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
    "upgrade-insecure-requests",
  ].join('; ');

  response.headers.set('Content-Security-Policy', csp);
  
  // Weitere Sicherheits-Header
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  
  // Custom Security Headers
  response.headers.set('X-DNS-Prefetch-Control', 'off');
  response.headers.set('X-Download-Options', 'noopen');
  response.headers.set('X-Permitted-Cross-Domain-Policies', 'none');
}
```

## Audit-Logging
```typescript
// lib/security/audit-logger.ts
import { PrismaClient } from '@prisma/client';
import { createHash } from 'crypto';

interface AuditLogEntry {
  action: string;
  userId?: string;
  requestId?: string;
  ip?: string;
  userAgent?: string;
  details?: Record<string, any>;
  severity?: 'low' | 'medium' | 'high' | 'critical';
  timestamp?: Date;
}

class AuditLogger {
  private prisma: PrismaClient;
  private batchSize: number = 100;
  private batchTimeout: number = 5000; // 5 Sekunden
  private batch: AuditLogEntry[] = [];
  private batchTimer: NodeJS.Timeout | null = null;

  constructor() {
    this.prisma = new PrismaClient();
    this.startBatchTimer();
  }

  async log(action: string, details: Record<string, any> = {}): Promise<void> {
    const entry: AuditLogEntry = {
      action,
      userId: details.userId,
      requestId: details.requestId,
      ip: this.hashIP(details.ip),
      userAgent: details.userAgent,
      details: this.sanitizeDetails(details),
      severity: this.determineSeverity(action, details),
      timestamp: new Date(),
    };

    this.batch.push(entry);

    // Batch voll oder kritische Aktion
    if (this.batch.length >= this.batchSize || entry.severity === 'critical') {
      await this.flushBatch();
    }
  }

  private async flushBatch(): Promise<void> {
    if (this.batch.length === 0) return;

    try {
      const entries = [...this.batch];
      this.batch = [];

      await this.prisma.auditLog.createMany({
        data: entries.map(entry => ({
          action: entry.action,
          userId: entry.userId,
          requestId: entry.requestId,
          ipHash: entry.ip,
          userAgent: entry.userAgent,
          details: entry.details,
          severity: entry.severity,
          timestamp: entry.timestamp,
        })),
      });

      // Kritische Events sofort an Security-Team senden
      const criticalEvents = entries.filter(e => e.severity === 'critical');
      if (criticalEvents.length > 0) {
        await this.notifySecurityTeam(criticalEvents);
      }

    } catch (error) {
      console.error('Audit-Logging Fehler:', error);
      // Fallback: Lokales Logging
      this.batch.forEach(entry => {
        console.log(`[AUDIT] ${entry.action}:`, entry);
      });
    }
  }

  private startBatchTimer(): void {
    this.batchTimer = setInterval(() => {
      this.flushBatch();
    }, this.batchTimeout);
  }

  private hashIP(ip: string | undefined): string | undefined {
    if (!ip || ip === 'unknown') return undefined;
    
    // IP-Adresse hashen für Datenschutz
    return createHash('sha256').update(ip + process.env.IP_SALT).digest('hex');
  }

  private sanitizeDetails(details: Record<string, any>): Record<string, any> {
    const sanitized = { ...details };
    
    // Sensible Daten entfernen
    delete sanitized.password;
    delete sanitized.token;
    delete sanitized.apiKey;
    delete sanitized.secret;
    
    // Große Objekte kürzen
    Object.keys(sanitized).forEach(key => {
      if (typeof sanitized[key] === 'object' && sanitized[key] !== null) {
        sanitized[key] = '[Object]';
      }
      if (typeof sanitized[key] === 'string' && sanitized[key].length > 1000) {
        sanitized[key] = sanitized[key].substring(0, 1000) + '...';
      }
    });
    
    return sanitized;
  }

  private determineSeverity(action: string, details: Record<string, any>): 'low' | 'medium' | 'high' | 'critical' {
    // Kritische Aktionen
    if (['user_deletion', 'admin_privilege_change', 'security_violation'].includes(action)) {
      return 'critical';
    }
    
    // Hohe Aktionen
    if (['user_creation', 'data_export', 'bulk_operation'].includes(action)) {
      return 'high';
    }
    
    // Mittlere Aktionen
    if (['data_modification', 'permission_change'].includes(action)) {
      return 'medium';
    }
    
    // Niedrige Aktionen
    return 'low';
  }

  private async notifySecurityTeam(events: AuditLogEntry[]): Promise<void> {
    // E-Mail-Benachrichtigung an Security-Team
    if (process.env.SECURITY_EMAIL) {
      try {
        await this.sendSecurityAlert(events);
      } catch (error) {
        console.error('Security-Benachrichtigung fehlgeschlagen:', error);
      }
    }
  }

  private async sendSecurityAlert(events: AuditLogEntry[]): Promise<void> {
    // Implementierung der E-Mail-Benachrichtigung
    // Hier würde die tatsächliche E-Mail-Logik implementiert
    console.log('SECURITY ALERT:', events);
  }

  // Manuelles Flushen
  async flush(): Promise<void> {
    await this.flushBatch();
  }

  // Cleanup
  destroy(): void {
    if (this.batchTimer) {
      clearInterval(this.batchTimer);
    }
    this.flush();
  }
}

export const auditLogger = new AuditLogger();
```

## Input-Validierung mit Zod
```typescript
// lib/security/validation.ts
import { z } from 'zod';

// Basis-Validierungsschemas
export const baseValidationSchemas = {
  // ID-Validierung
  id: z.string().uuid('Ungültige ID'),
  
  // E-Mail-Validierung
  email: z.string().email('Ungültige E-Mail-Adresse').max(255, 'E-Mail zu lang'),
  
  // Passwort-Validierung
  password: z.string()
    .min(8, 'Passwort muss mindestens 8 Zeichen lang sein')
    .max(128, 'Passwort zu lang')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Passwort muss Klein- und Großbuchstaben sowie Zahlen enthalten'),
  
  // Name-Validierung
  name: z.string()
    .min(2, 'Name muss mindestens 2 Zeichen lang sein')
    .max(100, 'Name zu lang')
    .regex(/^[a-zA-ZäöüßÄÖÜ\s-']+$/, 'Name enthält ungültige Zeichen'),
  
  // URL-Validierung
  url: z.string().url('Ungültige URL').max(2048, 'URL zu lang'),
  
  // Telefonnummer-Validierung
  phone: z.string()
    .regex(/^[\+]?[0-9\s\-\(\)]{7,20}$/, 'Ungültige Telefonnummer')
    .max(20, 'Telefonnummer zu lang'),
};

// Erweiterte Validierungsschemas
export const extendedValidationSchemas = {
  // Benutzer-Validierung
  user: z.object({
    email: baseValidationSchemas.email,
    firstName: baseValidationSchemas.name,
    lastName: baseValidationSchemas.name,
    phone: baseValidationSchemas.phone.optional(),
    companyCode: z.string().max(50, 'Unternehmenscode zu lang').optional(),
  }),

  // Modul-Validierung
  module: z.object({
    title: z.string().min(3, 'Titel zu kurz').max(200, 'Titel zu lang'),
    description: z.string().min(10, 'Beschreibung zu kurz').max(2000, 'Beschreibung zu lang'),
    content: z.string().min(1, 'Inhalt erforderlich'),
    difficulty: z.enum(['beginner', 'intermediate', 'advanced']),
    tags: z.array(z.string().max(50)).max(10, 'Zu viele Tags'),
    estimatedDuration: z.number().min(1, 'Dauer muss mindestens 1 Minute sein').max(480, 'Dauer zu lang'),
  }),

  // Quiz-Validierung
  quiz: z.object({
    title: z.string().min(3, 'Titel zu kurz').max(200, 'Titel zu lang'),
    questions: z.array(z.object({
      question: z.string().min(5, 'Frage zu kurz').max(1000, 'Frage zu lang'),
      options: z.array(z.string().min(1, 'Option zu kurz').max(500, 'Option zu lang')).min(2, 'Mindestens 2 Optionen').max(6, 'Maximal 6 Optionen'),
      correctAnswer: z.number().min(0, 'Ungültige Antwort'),
      explanation: z.string().max(1000, 'Erklärung zu lang').optional(),
    })).min(1, 'Mindestens eine Frage erforderlich').max(50, 'Zu viele Fragen'),
  }),

  // Datei-Upload-Validierung
  fileUpload: z.object({
    filename: z.string().min(1, 'Dateiname erforderlich').max(255, 'Dateiname zu lang'),
    mimetype: z.string().regex(/^(image|video|audio|application|text)\//, 'Ungültiger Dateityp'),
    size: z.number().max(100 * 1024 * 1024, 'Datei zu groß (max. 100MB)'),
  }),
};

// Sanitization-Funktionen
export const sanitization = {
  // HTML-Sanitization
  html: (input: string): string => {
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  },

  // SQL-Injection-Schutz
  sql: (input: string): string => {
    const sqlKeywords = [
      'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER',
      'UNION', 'EXEC', 'EXECUTE', 'SCRIPT', 'DECLARE', 'CAST', 'CONVERT'
    ];
    
    let sanitized = input;
    sqlKeywords.forEach(keyword => {
      const regex = new RegExp(keyword, 'gi');
      sanitized = sanitized.replace(regex, `[${keyword}]`);
    });
    
    return sanitized;
  },

  // XSS-Schutz
  xss: (input: string): string => {
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '');
  },
};

// Validierungs-Middleware
export function validateRequest<T>(schema: z.ZodSchema<T>) {
  return async (request: Request): Promise<{ success: true; data: T } | { success: false; errors: string[] }> => {
    try {
      const body = await request.json();
      const validatedData = schema.parse(body);
      return { success: true, data: validatedData };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return { 
          success: false, 
          errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) 
        };
      }
      return { success: false, errors: ['Validierung fehlgeschlagen'] };
    }
  };
}
```

## DSGVO-Compliance
```typescript
// lib/security/gdpr.ts
import { PrismaClient } from '@prisma/client';
import { auditLogger } from './audit-logger';

interface GDPRRequest {
  userId: string;
  requestType: 'data_export' | 'data_deletion' | 'data_rectification';
  reason?: string;
  contactEmail: string;
}

class GDPRCompliance {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  // Datenexport für DSGVO
  async exportUserData(userId: string): Promise<Record<string, any>> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
        include: {
          profile: true,
          learningProgress: true,
          achievements: true,
          quizResults: true,
          forumPosts: true,
          notifications: true,
        },
      });

      if (!user) {
        throw new Error('Benutzer nicht gefunden');
      }

      // Audit-Log
      await auditLogger.log('gdpr_data_export', {
        userId,
        timestamp: new Date().toISOString(),
      });

      return {
        exportDate: new Date().toISOString(),
        userId: user.id,
        personalData: {
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          createdAt: user.createdAt,
          lastLogin: user.lastLogin,
        },
        profile: user.profile,
        learningData: {
          progress: user.learningProgress,
          achievements: user.achievements,
          quizResults: user.quizResults,
        },
        socialData: {
          forumPosts: user.forumPosts,
          notifications: user.notifications,
        },
      };

    } catch (error) {
      await auditLogger.log('gdpr_export_error', {
        userId,
        error: error.message,
        timestamp: new Date().toISOString(),
      });
      throw error;
    }
  }

  // Datenlöschung für DSGVO
  async deleteUserData(userId: string): Promise<void> {
    try {
      // Audit-Log vor der Löschung
      await auditLogger.log('gdpr_data_deletion_started', {
        userId,
        timestamp: new Date().toISOString(),
      });

      // Daten anonymisieren statt löschen (für Audit-Zwecke)
      await this.prisma.user.update({
        where: { id: userId },
        data: {
          email: `deleted_${Date.now()}@deleted.com`,
          firstName: 'Gelöscht',
          lastName: 'Benutzer',
          isDeleted: true,
          deletedAt: new Date(),
        },
      });

      // Persönliche Daten löschen
      await this.prisma.userProfile.deleteMany({
        where: { userId },
      });

      await this.prisma.learningProgress.deleteMany({
        where: { userId },
      });

      await this.prisma.achievement.deleteMany({
        where: { userId },
      });

      await this.prisma.quizResult.deleteMany({
        where: { userId },
      });

      await this.prisma.forumPost.deleteMany({
        where: { userId },
      });

      await this.prisma.notification.deleteMany({
        where: { userId },
      });

      // Audit-Log nach der Löschung
      await auditLogger.log('gdpr_data_deletion_completed', {
        userId,
        timestamp: new Date().toISOString(),
      });

    } catch (error) {
      await auditLogger.log('gdpr_deletion_error', {
        userId,
        error: error.message,
        timestamp: new Date().toISOString(),
      });
      throw error;
    }
  }

  // Datenberichtigung für DSGVO
  async rectifyUserData(userId: string, corrections: Record<string, any>): Promise<void> {
    try {
      // Audit-Log
      await auditLogger.log('gdpr_data_rectification', {
        userId,
        corrections,
        timestamp: new Date().toISOString(),
      });

      // Erlaubte Felder für Berichtigung
      const allowedFields = ['firstName', 'lastName', 'phone'];
      const validCorrections: Record<string, any> = {};

      Object.keys(corrections).forEach(key => {
        if (allowedFields.includes(key)) {
          validCorrections[key] = corrections[key];
        }
      });

      if (Object.keys(validCorrections).length > 0) {
        await this.prisma.user.update({
          where: { id: userId },
          data: validCorrections,
        });
      }

    } catch (error) {
      await auditLogger.log('gdpr_rectification_error', {
        userId,
        error: error.message,
        timestamp: new Date().toISOString(),
      });
      throw error;
    }
  }

  // Consent-Management
  async updateConsent(userId: string, consentType: string, granted: boolean): Promise<void> {
    try {
      await this.prisma.userConsent.upsert({
        where: {
          userId_consentType: {
            userId,
            consentType,
          },
        },
        update: {
          granted,
          updatedAt: new Date(),
        },
        create: {
          userId,
          consentType,
          granted,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      });

      await auditLogger.log('consent_updated', {
        userId,
        consentType,
        granted,
        timestamp: new Date().toISOString(),
      });

    } catch (error) {
      await auditLogger.log('consent_update_error', {
        userId,
        error: error.message,
        timestamp: new Date().toISOString(),
      });
      throw error;
    }
  }

  // Cookie-Consent prüfen
  async checkCookieConsent(userId: string): Promise<boolean> {
    try {
      const consent = await this.prisma.userConsent.findUnique({
        where: {
          userId_consentType: {
            userId,
            consentType: 'cookies',
          },
        },
      });

      return consent?.granted || false;
    } catch (error) {
      console.error('Cookie-Consent-Prüfung fehlgeschlagen:', error);
      return false;
    }
  }
}

export const gdprCompliance = new GDPRCompliance();
```

## Umgebungsvariablen für Sicherheit
```bash
# .env
# ========================================
# SICHERHEIT
# ========================================
# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_DEFAULT_MAX=100
RATE_LIMIT_DEFAULT_WINDOW=900000
RATE_LIMIT_AUTH_MAX=5
RATE_LIMIT_AUTH_WINDOW=900000
RATE_LIMIT_API_MAX=60
RATE_LIMIT_API_WINDOW=60000

# CORS
CORS_ENABLED=true
CORS_ALLOWED_ORIGINS=https://azubi-lxp.com,https://www.azubi-lxp.com
CORS_ALLOW_CREDENTIALS=true
CORS_MAX_AGE=86400

# Audit Logging
AUDIT_LOGGING_ENABLED=true
AUDIT_LOG_BATCH_SIZE=100
AUDIT_LOG_BATCH_TIMEOUT=5000
SECURITY_EMAIL=security@azubi-lxp.com

# DSGVO
GDPR_ENABLED=true
GDPR_DATA_RETENTION_DAYS=2555
GDPR_AUTO_DELETION_ENABLED=true
GDPR_CONSENT_REQUIRED=true

# Verschlüsselung
ENCRYPTION_ENABLED=true
ENCRYPTION_ALGORITHM=AES-256-GCM
DB_ENCRYPTION_ENABLED=true
IP_SALT=your-secret-salt-here

# Sicherheits-Header
SECURITY_HEADERS_ENABLED=true
CSP_ENABLED=true
HSTS_ENABLED=true
XSS_PROTECTION_ENABLED=true

# Session-Management
SESSION_TIMEOUT_MINUTES=30
SESSION_MAX_AGE_DAYS=7
REFRESH_TOKEN_ENABLED=true
REFRESH_TOKEN_EXPIRY_DAYS=30

# API-Sicherheit
API_KEY_REQUIRED=false
API_RATE_LIMIT_ENABLED=true
INPUT_VALIDATION_ENABLED=true
SQL_INJECTION_PROTECTION_ENABLED=true
XSS_PROTECTION_ENABLED=true
```
description:
globs:
alwaysApply: true
---
